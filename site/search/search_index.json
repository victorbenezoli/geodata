{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#ibge-geodata","title":"ibge-geodata","text":"<p>ibge-geodata is a Python package to access and manipulate Brazilian IBGE territorial geospatial data directly in DataFrames and GeoDataFrames.</p>"},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li> Territorial polygons</li> </ul> <p>Download geometries for countries, regions, states, municipalities, and intermediate/immediate regions.</p> <ul> <li> Aligned metadata</li> </ul> <p>IBGE localities API metadata automatically joined to geometries by <code>id</code>.</p> <ul> <li> Point localisation</li> </ul> <p>Find the state, municipality, and region that contain any geographic point.</p> <ul> <li> Quick visualisation</li> </ul> <p>Generate maps in one line with <code>geodata.plot()</code>.</p>"},{"location":"#quick-install","title":"Quick install","text":"<pre><code>pip install ibge-geodata\n</code></pre>"},{"location":"#minimal-example","title":"Minimal example","text":"<pre><code>from geodata import GeoData, GeoLevel, Quality, GeoLocator\nfrom geodata.utils.geocoords import GeoCoords\n\n# Polygons and metadata for all states\nstates = GeoData(GeoLevel.STATE, Quality.LOW)\nstates.plot()\n\n# Locate a point\nbrasilia = GeoCoords(lat=-15.7801, lon=-47.9292)\nloc = GeoLocator(brasilia)\nprint(loc.state)         # 'DF'\nprint(loc.municipality)  # 'Bras\u00edlia'\n</code></pre>"},{"location":"#navigation","title":"Navigation","text":"Page Description Installation Requirements and setup instructions Quickstart Practical guide with annotated examples API Reference Full documentation for all classes Examples Real-world use cases FAQ Frequently asked questions"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":""},{"location":"examples/#choropleth-map-of-states","title":"Choropleth map of states","text":"<pre><code>import matplotlib.pyplot as plt\nfrom geodata import GeoData, GeoLevel, Quality\n\nstates = GeoData(GeoLevel.STATE, Quality.LOW)\n\nax = states.polygons.plot(\n    column=\"nome\",\n    cmap=\"tab20\",\n    figsize=(14, 10),\n    legend=False,\n    edgecolor=\"white\",\n    linewidth=0.4,\n)\nax.set_title(\"Brazilian States\", fontsize=16)\nax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/#locate-multiple-points","title":"Locate multiple points","text":"<pre><code>from geodata import GeoLocator\nfrom geodata.utils.geocoords import GeoCoords\n\npoints = {\n    \"Bras\u00edlia\":     GeoCoords(lat=-15.7801, lon=-47.9292),\n    \"S\u00e3o Paulo\":   GeoCoords(lat=-23.5505, lon=-46.6333),\n    \"Manaus\":       GeoCoords(lat=-3.1190,  lon=-60.0217),\n    \"Porto Alegre\": GeoCoords(lat=-30.0346, lon=-51.2177),\n}\n\nfor city, coords in points.items():\n    loc = GeoLocator(coords)\n    print(f\"{city}: {loc.state} \u2014 {loc.municipality} ({loc.region})\")\n</code></pre>"},{"location":"examples/#calculate-distances-between-cities","title":"Calculate distances between cities","text":"<pre><code>from geodata.utils.geocoords import GeoCoords\n\ncapitals = {\n    \"Bras\u00edlia\":     GeoCoords(lat=-15.7801, lon=-47.9292),\n    \"Recife\":        GeoCoords(lat=-8.0539,  lon=-34.8811),\n    \"Porto Alegre\": GeoCoords(lat=-30.0346, lon=-51.2177),\n    \"Bel\u00e9m\":        GeoCoords(lat=-1.4558,  lon=-48.5044),\n}\n\norigin = capitals[\"Bras\u00edlia\"]\nfor dest, coords in capitals.items():\n    if dest == \"Bras\u00edlia\":\n        continue\n    dist = origin.distance_to(coords)\n    bearing = origin.bearing_to(coords)\n    print(f\"Bras\u00edlia \u2192 {dest}: {dist:.0f} km, bearing {bearing:.1f}\u00b0\")\n</code></pre>"},{"location":"examples/#convert-between-geographic-and-utm-coordinates","title":"Convert between geographic and UTM coordinates","text":"<pre><code>from geodata.utils.geocoords import GeoCoords\n\np = GeoCoords(lat=-15.7801, lon=-47.9292)\n\n# WGS-84 \u2192 UTM zone 22S\neasting, northing = p.to_utm(\"EPSG:32722\")\nprint(f\"E={easting:.0f}  N={northing:.0f}\")\n\n# UTM \u2192 WGS-84\nq = GeoCoords.from_utm(easting, northing, \"EPSG:32722\")\nprint(q)  # ~15.780100\u00b0S, 47.929200\u00b0W\n</code></pre>"},{"location":"examples/#serialisation-and-json-integration","title":"Serialisation and JSON integration","text":"<pre><code>import json\nfrom geodata.utils.geocoords import GeoCoords\n\np = GeoCoords(lat=-15.7801, lon=-47.9292)\n\n# Export\npayload = json.dumps(p.to_dict())\n\n# Import\nq = GeoCoords.from_dict(json.loads(payload))\nassert p == q\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":""},{"location":"faq/#downloads-are-slow-how-can-i-speed-things-up","title":"Downloads are slow. How can I speed things up?","text":"<p>Use <code>Quality.LOW</code>. Municipality polygons at maximum quality can be several MB each.</p> <pre><code>municipalities = GeoData(GeoLevel.MUNICIPALITY, Quality.LOW)\n</code></pre>"},{"location":"faq/#geolocator-returns-none-for-a-point-inside-brazil","title":"<code>GeoLocator</code> returns <code>None</code> for a point inside Brazil","text":"<p>This usually happens for points very close to state borders when polygon quality is low. Use <code>Quality.HIGH</code>:</p> <pre><code>loc = GeoLocator(coords, quality=Quality.HIGH)\n</code></pre>"},{"location":"faq/#can-i-use-degreeminutesecond-coordinates","title":"Can I use degree/minute/second coordinates?","text":"<p><code>GeoCoords</code> expects decimal degrees. Convert first:</p> <pre><code>def dms_to_dd(degrees, minutes, seconds, direction):\n    dd = degrees + minutes / 60 + seconds / 3600\n    return -dd if direction in (\"S\", \"W\") else dd\n\nlat = dms_to_dd(15, 46, 47.9, \"S\")   # -15.7800\nlon = dms_to_dd(47, 55, 45.1, \"W\")   # -47.9292\n</code></pre>"},{"location":"faq/#the-ibge-api-is-down-what-happens","title":"The IBGE API is down. What happens?","text":"<p><code>GeoDataBase</code> raises <code>requests.HTTPError</code>. You can catch and handle it:</p> <pre><code>import requests\ntry:\n    geodata = GeoData(GeoLevel.STATE, Quality.LOW)\n    gdf = geodata.polygons\nexcept requests.HTTPError as e:\n    print(f\"IBGE API error: {e}\")\n</code></pre>"},{"location":"faq/#how-do-i-save-polygons-locally","title":"How do I save polygons locally?","text":"<p>Use native GeoPandas methods:</p> <pre><code># GeoPackage (recommended)\nstates.polygons.to_file(\"states.gpkg\", driver=\"GPKG\")\n\n# GeoJSON\nstates.polygons.to_file(\"states.geojson\", driver=\"GeoJSON\")\n\n# Shapefile\nstates.polygons.to_file(\"states.shp\")\n</code></pre>"},{"location":"faq/#can-i-reproject-to-sirgas-2000","title":"Can I reproject to SIRGAS 2000?","text":"<p>Yes, use GeoPandas <code>to_crs</code>. SIRGAS 2000 is <code>EPSG:4674</code>:</p> <pre><code>gdf_sirgas = states.polygons.to_crs(\"EPSG:4674\")\n</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#installation","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>Operating system: Linux, macOS, or Windows</li> </ul>"},{"location":"install/#via-pip","title":"Via pip","text":"<pre><code>pip install ibge-geodata\n</code></pre>"},{"location":"install/#via-poetry","title":"Via Poetry","text":"<pre><code>poetry add ibge-geodata\n</code></pre>"},{"location":"install/#development-installation","title":"Development installation","text":"<p>Clone the repository and install all development dependencies:</p> <pre><code>git clone https://github.com/victorbenezoli/geodata.git\ncd geodata\npoetry install\n</code></pre>"},{"location":"install/#dependencies","title":"Dependencies","text":"Package Minimum version Purpose <code>geopandas</code> 1.0 GeoDataFrames and spatial operations <code>pyproj</code> \u2014 Coordinate reference system conversions <code>shapely</code> \u2014 Geometries and point-in-polygon <code>requests</code> 2.32 IBGE API calls <code>numpy</code> 2.0 Numerical operations <code>pandas</code> \u2014 Metadata DataFrames <code>matplotlib</code> 3.10 Map visualisation"},{"location":"install/#verification","title":"Verification","text":"<pre><code>import geodata\nprint(geodata.__version__)\n</code></pre>"},{"location":"license/","title":"License","text":""},{"location":"license/#license","title":"License","text":"<p>This project is distributed under the GNU General Public License (GPL).</p> <p>See the LICENSE.md file in the repository for the full text.</p>"},{"location":"license/#ibge-data","title":"IBGE data","text":"<p>The geospatial data returned by this package is obtained from the IBGE Mesh API and the IBGE Localities API.</p> <p>Use of this data is subject to the terms established by IBGE. See the IBGE portal for more information.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":""},{"location":"quickstart/#imports","title":"Imports","text":"<pre><code>from geodata import GeoData, GeoLevel, Quality, GeoLocator\nfrom geodata.utils.geocoords import GeoCoords\n</code></pre>"},{"location":"quickstart/#1-download-polygons-and-metadata","title":"1. Download polygons and metadata","text":"<p><code>GeoData</code> is the main entry point. Combine a <code>GeoLevel</code> with a <code>Quality</code>:</p> <pre><code># All Brazilian states at maximum quality\nstates = GeoData(GeoLevel.STATE, Quality.HIGH)\n\n# GeoDataFrame with geometries + aligned metadata\nprint(states.polygons)\n\n# Metadata only (id, nome, sigla, etc.)\nprint(states.metadata)\n</code></pre>"},{"location":"quickstart/#available-levels","title":"Available levels","text":"<code>GeoLevel</code> Description <code>COUNTRY</code> Country (Brazil) <code>REGION</code> Macro-regions (North, South\u2026) <code>INTERMEDIATE_REGION</code> Intermediate regions <code>IMMEDIATE_REGION</code> Immediate regions <code>STATE</code> Federative units <code>MUNICIPALITY</code> Municipalities"},{"location":"quickstart/#available-qualities","title":"Available qualities","text":"<code>Quality</code> Resolution <code>LOW</code> Minimum \u2014 smallest files, fastest download <code>MEDIUM</code> Intermediate <code>HIGH</code> Maximum \u2014 most accurate boundaries"},{"location":"quickstart/#2-visualise","title":"2. Visualise","text":"<pre><code>import matplotlib.pyplot as plt\n\nstates.plot(column=\"nome\", legend=False, figsize=(10, 8))\nplt.title(\"Brazilian States\")\nplt.axis(\"off\")\nplt.show()\n</code></pre>"},{"location":"quickstart/#3-work-with-coordinates","title":"3. Work with coordinates","text":"<p><code>GeoCoords</code> represents a validated WGS-84 coordinate pair:</p> <pre><code>brasilia = GeoCoords(lat=-15.7801, lon=-47.9292)\nmanaus   = GeoCoords(lat=-3.1190,  lon=-60.0217)\n\n# Distance in km (haversine)\nprint(brasilia.distance_to(manaus))   # ~2689.6 km\n\n# Initial bearing in degrees\nprint(brasilia.bearing_to(manaus))    # ~322.0\u00b0\n\n# Convert to UTM\neasting, northing = brasilia.to_utm(\"EPSG:32722\")\n</code></pre>"},{"location":"quickstart/#4-locate-a-point","title":"4. Locate a point","text":"<p><code>GeoLocator</code> finds which administrative division a point belongs to:</p> <pre><code>loc = GeoLocator(GeoCoords(lat=-15.7801, lon=-47.9292))\n\nprint(loc.state)               # 'DF'\nprint(loc.municipality)        # 'Bras\u00edlia'\nprint(loc.region)              # 'Centro-Oeste'\nprint(loc.intermediate_region)\nprint(loc.immediate_region)\n\n# Full metadata row for any level\nprint(loc.locate(GeoLevel.STATE))\n\n# All levels at once\nprint(loc.all_levels())\n</code></pre> <p>Quality vs speed</p> <p>By default <code>GeoLocator</code> uses <code>Quality.LOW</code> to minimise download time. For points near state borders, use <code>Quality.HIGH</code> to avoid false negatives.</p>"},{"location":"api/geocoords/","title":"GeoCoords","text":"<p>Represents a validated WGS-84 geographic coordinate pair.</p> <pre><code>from geodata.utils.geocoords import GeoCoords\n</code></pre>"},{"location":"api/geocoords/#constructor","title":"Constructor","text":"<pre><code>GeoCoords(lat: float, lon: float)\n</code></pre> Parameter Valid range Description <code>lat</code> <code>[-90, 90]</code> Latitude in decimal degrees <code>lon</code> <code>[-180, 180]</code> Longitude in decimal degrees <p>Values are coerced to <code>float</code> automatically. Exceptions are raised for invalid inputs.</p>"},{"location":"api/geocoords/#attributes","title":"Attributes","text":"Attribute Type Description <code>lat</code> <code>float</code> Latitude <code>lon</code> <code>float</code> Longitude"},{"location":"api/geocoords/#alternative-constructors","title":"Alternative constructors","text":""},{"location":"api/geocoords/#from_tuple","title":"<code>from_tuple</code>","text":"<pre><code>@staticmethod\ndef from_tuple(coords: tuple[float, float]) -&gt; GeoCoords\n</code></pre> <pre><code>p = GeoCoords.from_tuple((-15.7801, -47.9292))\n</code></pre>"},{"location":"api/geocoords/#from_dict","title":"<code>from_dict</code>","text":"<pre><code>@staticmethod\ndef from_dict(data: dict[str, float]) -&gt; GeoCoords\n</code></pre> <pre><code>p = GeoCoords.from_dict({\"lat\": -15.7801, \"lon\": -47.9292})\n</code></pre>"},{"location":"api/geocoords/#from_utm","title":"<code>from_utm</code>","text":"<pre><code>@staticmethod\ndef from_utm(easting: float, northing: float, source_crs: str) -&gt; GeoCoords\n</code></pre> <pre><code>p = GeoCoords.from_utm(197055.0, 8254536.0, \"EPSG:32722\")\n</code></pre>"},{"location":"api/geocoords/#serialisation","title":"Serialisation","text":""},{"location":"api/geocoords/#to_tuple","title":"<code>to_tuple</code>","text":"<pre><code>(-15.7801, -47.9292) == GeoCoords(lat=-15.7801, lon=-47.9292).to_tuple()\n</code></pre>"},{"location":"api/geocoords/#to_dict","title":"<code>to_dict</code>","text":"<pre><code>{\"lat\": -15.7801, \"lon\": -47.9292} == GeoCoords(lat=-15.7801, lon=-47.9292).to_dict()\n</code></pre>"},{"location":"api/geocoords/#to_utm","title":"<code>to_utm</code>","text":"<pre><code>easting, northing = GeoCoords(lat=-15.7801, lon=-47.9292).to_utm(\"EPSG:32722\")\n</code></pre>"},{"location":"api/geocoords/#to_shapely_point","title":"<code>to_shapely_point</code>","text":"<pre><code>point = GeoCoords(lat=-15.7801, lon=-47.9292).to_shapely_point()\n# POINT (-47.9292 -15.7801)\n</code></pre>"},{"location":"api/geocoords/#geodesic-calculations","title":"Geodesic calculations","text":""},{"location":"api/geocoords/#distance_to","title":"<code>distance_to</code>","text":"<p>Great-circle distance in km using the Haversine formula.</p> <pre><code>brasilia = GeoCoords(lat=-15.7801, lon=-47.9292)\nmanaus   = GeoCoords(lat=-3.1190,  lon=-60.0217)\n\nprint(brasilia.distance_to(manaus))  # ~2689.6 km\n</code></pre>"},{"location":"api/geocoords/#bearing_to","title":"<code>bearing_to</code>","text":"<p>Initial bearing in degrees (0\u2013360\u00b0), measured clockwise from true north.</p> <pre><code>print(brasilia.bearing_to(manaus))  # ~322.0\u00b0\n</code></pre>"},{"location":"api/geocoords/#string-representation","title":"String representation","text":"<pre><code>str(GeoCoords(lat=-15.7801, lon=-47.9292))\n# '15.780100\u00b0S, 47.929200\u00b0W'\n</code></pre>"},{"location":"api/geodata/","title":"GeoData","text":""},{"location":"api/geodata/#geodata","title":"GeoData","text":"<p>Main class for accessing IBGE territorial polygons and metadata.</p> <pre><code>from geodata import GeoData, GeoLevel, Quality\n</code></pre>"},{"location":"api/geodata/#constructor","title":"Constructor","text":"<pre><code>GeoData(geolevel: GeoLevel, quality: Quality)\n</code></pre> Parameter Type Description <code>geolevel</code> <code>GeoLevel</code> Desired geographic level <code>quality</code> <code>Quality</code> Polygon resolution"},{"location":"api/geodata/#properties","title":"Properties","text":""},{"location":"api/geodata/#polygons","title":"<code>polygons</code>","text":"<pre><code>@property\ndef polygons(self) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Returns a <code>GeoDataFrame</code> with geometries and all metadata joined by <code>id</code>.</p> <pre><code>states = GeoData(GeoLevel.STATE, Quality.LOW)\ngdf = states.polygons\nprint(gdf.columns)  # ['id', 'nome', 'sigla', ..., 'geometry']\n</code></pre>"},{"location":"api/geodata/#metadata","title":"<code>metadata</code>","text":"<pre><code>@property\ndef metadata(self) -&gt; pd.DataFrame\n</code></pre> <p>Returns metadata only (no geometry) from the IBGE localities API.</p> <pre><code>meta = states.metadata\nprint(meta[[\"id\", \"nome\", \"sigla\"]])\n</code></pre>"},{"location":"api/geodata/#methods","title":"Methods","text":""},{"location":"api/geodata/#plot","title":"<code>plot</code>","text":"<pre><code>def plot(self, **kwargs) -&gt; None\n</code></pre> <p>Shortcut for <code>self.polygons.plot(...)</code>. Accepts all GeoPandas/Matplotlib <code>plot</code> arguments.</p> <pre><code>states.plot(column=\"nome\", figsize=(12, 8))\n</code></pre>"},{"location":"api/geodata/#representation","title":"Representation","text":"<pre><code>repr(GeoData(GeoLevel.STATE, Quality.LOW))\n# \"GeoData(geolevel=GeoLevel.STATE, quality=Quality.LOW)\"\n</code></pre> <pre><code>repr(GeoData(GeoLevel.STATE, Quality.LOW))\n# \"GeoData(geolevel=GeoLevel.STATE, quality=Quality.LOW)\"\n</code></pre>"},{"location":"api/geolevel/","title":"GeoLevel","text":"<p>Enum representing the geographic level of a territorial division.</p> <pre><code>from geodata import GeoLevel\n</code></pre>"},{"location":"api/geolevel/#values","title":"Values","text":"Member <code>spatial</code> <code>metadata</code> Description <code>COUNTRY</code> <code>\"paises\"</code> <code>\"paises\"</code> Brazil (country level) <code>REGION</code> <code>\"regiao\"</code> <code>\"regioes\"</code> Macro-regions <code>INTERMEDIATE_REGION</code> <code>\"intermediaria\"</code> <code>\"regioes-intermediarias\"</code> Intermediate regions <code>IMMEDIATE_REGION</code> <code>\"imediata\"</code> <code>\"regioes-imediatas\"</code> Immediate regions <code>STATE</code> <code>\"UF\"</code> <code>\"estados\"</code> Federative units <code>MUNICIPALITY</code> <code>\"municipio\"</code> <code>\"municipios\"</code> Municipalities"},{"location":"api/geolevel/#member-attributes","title":"Member attributes","text":"<p>Each <code>GeoLevel</code> member exposes two sub-attributes used internally:</p> Attribute Type Usage <code>.spatial</code> <code>SpatialLevel</code> <code>intrarregiao</code> parameter of the mesh API <code>.metadata</code> <code>Metadata</code> URL segment of the localities API"},{"location":"api/geolevel/#usage","title":"Usage","text":"<pre><code>from geodata import GeoData, GeoLevel, Quality\n\ngeodata = GeoData(GeoLevel.MUNICIPALITY, Quality.LOW)\nprint(geodata.polygons.head())\n</code></pre> <p>Iterate over all levels:</p> <pre><code>for level in GeoLevel:\n    print(level.name, level.spatial)\n</code></pre>"},{"location":"api/geolocator/","title":"GeoLocator","text":"<p>Locates the administrative divisions that contain a geographic point.</p> <pre><code>from geodata import GeoLocator, GeoLevel, Quality\nfrom geodata.utils.geocoords import GeoCoords\n</code></pre>"},{"location":"api/geolocator/#constructor","title":"Constructor","text":"<pre><code>GeoLocator(coords: GeoCoords, quality: Quality = Quality.LOW)\n</code></pre> Parameter Type Default Description <code>coords</code> <code>GeoCoords</code> \u2014 Point to locate <code>quality</code> <code>Quality</code> <code>Quality.LOW</code> Resolution of the downloaded polygons <p>All attributes are resolved eagerly in <code>__post_init__</code>: polygons for every level are downloaded and the point-in-polygon test is performed immediately on construction.</p>"},{"location":"api/geolocator/#attributes","title":"Attributes","text":"Attribute Type Description <code>coords</code> <code>GeoCoords</code> The point provided at construction time <code>quality</code> <code>Quality</code> Polygon resolution <code>state</code> <code>str \\| None</code> State abbreviation (e.g. <code>'SP'</code>, <code>'DF'</code>) <code>municipality</code> <code>str \\| None</code> Municipality name <code>region</code> <code>str \\| None</code> Macro-region name <code>intermediate_region</code> <code>str \\| None</code> Intermediate region name <code>immediate_region</code> <code>str \\| None</code> Immediate region name <p><code>None</code> is returned when the point falls outside Brazilian territory (e.g. at sea).</p>"},{"location":"api/geolocator/#methods","title":"Methods","text":""},{"location":"api/geolocator/#locate","title":"<code>locate</code>","text":"<pre><code>def locate(self, geolevel: GeoLevel) -&gt; pd.Series | None\n</code></pre> <p>Returns the full metadata row of the polygon that contains the point at the given level.</p> <pre><code>loc = GeoLocator(GeoCoords(lat=-15.7801, lon=-47.9292))\nrow = loc.locate(GeoLevel.STATE)\nprint(row[\"nome\"])   # 'Distrito Federal'\nprint(row[\"sigla\"])  # 'DF'\nprint(row[\"id\"])     # 53\n</code></pre>"},{"location":"api/geolocator/#all_levels","title":"<code>all_levels</code>","text":"<pre><code>def all_levels(self) -&gt; dict[GeoLevel, pd.Series | None]\n</code></pre> <p>Returns a dictionary with results for all administrative levels.</p> <pre><code>result = loc.all_levels()\nfor level, row in result.items():\n    name = row[\"nome\"] if row is not None else \"\u2014\"\n    print(f\"{level.name}: {name}\")\n</code></pre>"},{"location":"api/geolocator/#full-example","title":"Full example","text":"<pre><code>from geodata import GeoLocator, Quality\nfrom geodata.utils.geocoords import GeoCoords\n\ncoords = GeoCoords(lat=-23.5505, lon=-46.6333)  # S\u00e3o Paulo\nloc = GeoLocator(coords, quality=Quality.LOW)\n\nprint(loc.state)               # 'SP'\nprint(loc.municipality)        # 'S\u00e3o Paulo'\nprint(loc.region)              # 'Sudeste'\nprint(loc.intermediate_region)\nprint(loc.immediate_region)\n</code></pre> <p>Point near a border</p> <p>For points very close to state borders, use <code>Quality.HIGH</code> to ensure the low-resolution geometry does not exclude the point.</p>"},{"location":"api/quality/","title":"Quality","text":"<p>Enum that controls the resolution of polygons downloaded from the IBGE mesh API.</p> <pre><code>from geodata import Quality\n</code></pre>"},{"location":"api/quality/#values","title":"Values","text":"Member API value Description <code>LOW</code> <code>\"minima\"</code> Lowest resolution \u2014 smallest files, fastest download <code>MEDIUM</code> <code>\"intermediaria\"</code> Intermediate resolution <code>HIGH</code> <code>\"maxima\"</code> Highest resolution \u2014 most accurate boundaries"},{"location":"api/quality/#when-to-use-each-level","title":"When to use each level","text":"Situation Recommended quality General visualisations / dashboards <code>LOW</code> Regional analyses <code>MEDIUM</code> Points near borders <code>HIGH</code> Cartographic publications <code>HIGH</code>"},{"location":"api/quality/#usage","title":"Usage","text":"<pre><code>from geodata import GeoData, GeoLevel, Quality\n\n# Fast download for exploration\nstates = GeoData(GeoLevel.STATE, Quality.LOW)\n\n# High-accuracy download for analysis\nstates_hq = GeoData(GeoLevel.STATE, Quality.HIGH)\n</code></pre>"}]}